/********************************************************************************
* ClassSyntaxFactory.cs                                                         *
*                                                                               *
* Author: Denes Solti                                                           *
********************************************************************************/
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Threading;

using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Solti.Utils.Proxy.Internals
{
    internal class ClassSyntaxFactory: SyntaxFactoryBase, IUnitSyntaxFactory
    {
        public CompilationUnitSyntax? Unit { get; private set; }

        public OutputType OutputType => OutputType.Module;

        public IReadOnlyCollection<string>? Classes { get; } = new[] { "GeneratedClass" };

        public IReadOnlyCollection<IMemberSyntaxFactory> MemberSyntaxFactories { get; protected set; } = Array.Empty<IMemberSyntaxFactory>();

        protected virtual MemberDeclarationSyntax GenerateClass(IEnumerable<MemberDeclarationSyntax> members) => throw new NotImplementedException();

        public override bool Build(CancellationToken cancellation)
        {
            if (Unit is not null) return false;

            Unit = CompilationUnit().WithMembers
            (
                members: SingletonList<MemberDeclarationSyntax>
                (
                    GenerateClass
                    (
                        BuildMembers()
                    )
                )
            )
            .WithAttributeLists
            (
                SingletonList
                (
                    AttributeList
                    (
                        new[] 
                        {
                            CreateAttribute<AssemblyDescriptionAttribute>(AsLiteral("Generated by ProxyGen.NET"))
                        }
#if IGNORE_VISIBILITY
                        .Concat
                        (
                            ignoreAccessChecksTo.Select(asmName => (SyntaxNodeOrToken) CreateAttribute<IgnoresAccessChecksToAttribute>(AsLiteral(asmName)))
                        )
#endif
                        .ToSyntaxList()
                    )
                    .WithTarget
                    (
                        AttributeTargetSpecifier(Token(SyntaxKind.AssemblyKeyword))
                    )
                )
            );

            return true;

            static LiteralExpressionSyntax AsLiteral(string param) => LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(param));

            IEnumerable<MemberDeclarationSyntax> BuildMembers() 
            {
                foreach (IMemberSyntaxFactory syntaxFactory in MemberSyntaxFactories) 
                {
                    syntaxFactory.Build(cancellation);

                    foreach (MemberDeclarationSyntax memberDeclaration in syntaxFactory.Members!)
                    {
                        yield return memberDeclaration;
                    }

                    AddTypesFrom(syntaxFactory);
                }
            }
        }
    }
}