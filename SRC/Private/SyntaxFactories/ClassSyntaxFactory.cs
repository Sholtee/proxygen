/********************************************************************************
* ClassSyntaxFactory.cs                                                         *
*                                                                               *
* Author: Denes Solti                                                           *
********************************************************************************/
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Threading;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Solti.Utils.Proxy.Internals
{
    internal abstract class ClassSyntaxFactory: SyntaxFactoryBase, IUnitSyntaxFactory
    {
        private const string CONTAINING_NS = "Proxies";

        private readonly IReadOnlyCollection<string> FDefinedClasses;

        public CompilationUnitSyntax? Unit { get; private set; }

        public OutputType OutputType { get; }

        IReadOnlyCollection<string> IUnitSyntaxFactory.DefinedClasses => FDefinedClasses;

        public abstract IReadOnlyCollection<IMemberSyntaxFactory> MemberSyntaxFactories { get; }

        public abstract string ClassName { get; }

        protected abstract MemberDeclarationSyntax GenerateClass(IEnumerable<MemberDeclarationSyntax> members);

        protected ClassSyntaxFactory(OutputType outputType)
        {
            OutputType = outputType;

            FDefinedClasses = new[]
            {
                OutputType switch
                {
                    OutputType.Unit => CONTAINING_NS + Type.Delimiter + ClassName,
                    OutputType.Module => ClassName,
                    _ => throw new NotSupportedException()
                }
            };
        }

        public override bool Build(CancellationToken cancellation)
        {
            if (Unit is not null) return false;

            SyntaxList<MemberDeclarationSyntax> classImpl = SingletonList<MemberDeclarationSyntax>
            (
                GenerateClass
                (
                    BuildMembers()
                )
            );

            Unit = OutputType switch
            {
                OutputType.Unit => CompilationUnit().WithMembers
                (
                    members: SingletonList<MemberDeclarationSyntax>
                    (
                        NamespaceDeclaration
                        (
                            IdentifierName(CONTAINING_NS)
                        )
                        .WithMembers
                        (
                            members: classImpl
                        )
                    )
                ),

                OutputType.Module => CompilationUnit().WithMembers
                (
                    members: classImpl
                )
                .WithAttributeLists
                (
                    SingletonList
                    (
                        AttributeList
                        (
                            new[]
                            {
                                CreateAttribute<AssemblyDescriptionAttribute>(AsLiteral("Generated by ProxyGen.NET"))
                            }
#if IGNORE_VISIBILITY
                            .Concat
                            (
                                ignoreAccessChecksTo.Select(asmName => (SyntaxNodeOrToken) CreateAttribute<IgnoresAccessChecksToAttribute>(AsLiteral(asmName)))
                            )
#endif
                            .ToSyntaxList()
                        )
                        .WithTarget
                        (
                            AttributeTargetSpecifier(Token(SyntaxKind.AssemblyKeyword))
                        )
                    )
                ),

                _ => throw new NotSupportedException()
            };

            return true;

            static LiteralExpressionSyntax AsLiteral(string param) => LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(param));

            IEnumerable<MemberDeclarationSyntax> BuildMembers() 
            {
                foreach (IMemberSyntaxFactory syntaxFactory in MemberSyntaxFactories) 
                {
                    syntaxFactory.Build(cancellation);

                    foreach (MemberDeclarationSyntax memberDeclaration in syntaxFactory.Members!)
                    {
                        yield return memberDeclaration;
                    }

                    AddTypesFrom(syntaxFactory);
                }
            }
        }
    }
}